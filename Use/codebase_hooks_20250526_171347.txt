================================================================================
CODEBASE EXTRACTION REPORT
================================================================================
Projet: hooks
Chemin: D:\DONNEES\Bureau\WORSPACE-STAGIAIRE\Next.js 2025\algoway-front\algoway-front\src\hooks
Date d'extraction: 2025-05-26 17:13:47
Syst√®me: windows 64bit

STATISTIQUES DU PROJET:
------------------------------
üìÅ Total dossiers: 1
üìÑ Total fichiers: 5
üíª Fichiers de code: 5

STRUCTURE DU PROJET:
------------------------------
hooks/
‚îî‚îÄ‚îÄ dividends/
    ‚îú‚îÄ‚îÄ useAutoScroll.ts
    ‚îú‚îÄ‚îÄ useChartJs.ts
    ‚îú‚îÄ‚îÄ useRevealOnScroll.ts
    ‚îú‚îÄ‚îÄ useScrollManagement.ts
    ‚îî‚îÄ‚îÄ useTradingViewChart.ts

================================================================================
CONTENU DES FICHIERS DE CODE
================================================================================

['dividends\useAutoScroll.ts': [
--------------------------------------------------
// # hook client
'use client';
import { useEffect, useRef, useCallback, useState } from 'react';

interface UseAutoScrollOptions {
  pixelsPerSecond?: number;
  pauseDelayMs?: number;
  isEnabled?: boolean;
}

export function useAutoScroll(
  scrollContainerRef: React.RefObject<HTMLElement | null>, // Signature corrig√©e pour accepter null
  options: UseAutoScrollOptions = {}
) {
  const { pixelsPerSecond = 24.4, pauseDelayMs = 3333, isEnabled = true } = options;
  const animationFrameIdRef = useRef<number | null>(null);
  const lastTimestampRef = useRef<number>(0);
  const directionRef = useRef<1 | -1>(1);
  const isInteractingRef = useRef<boolean>(false);
  const isPausedAtEdgeRef = useRef<boolean>(false);
  const pauseTimeoutIdRef = useRef<NodeJS.Timeout | null>(null);
  const [isActuallyScrolling, setIsActuallyScrolling] = useState(false);

  const animateScroll = useCallback((timestamp: number) => {
    if (!scrollContainerRef.current || isInteractingRef.current || isPausedAtEdgeRef.current || !isEnabled) {
      animationFrameIdRef.current = null;
      return;
    }
    // ... (reste de la logique animateScroll inchang√©e par rapport √† ma Prop. 7) ...
    if (lastTimestampRef.current === 0) {
      lastTimestampRef.current = timestamp;
    }
    const deltaTime = (timestamp - lastTimestampRef.current) / 1000; // en secondes
    lastTimestampRef.current = timestamp;

    const scrollAmount = pixelsPerSecond * deltaTime * directionRef.current;
    const element = scrollContainerRef.current;
    const currentScrollTop = element.scrollTop;
    let newScrollTop = currentScrollTop + scrollAmount;

    const atBottom = (currentScrollTop >= element.scrollHeight - element.clientHeight - 1);
    const atTop = (currentScrollTop <= 1);

    if (directionRef.current === 1 && atBottom) {
      newScrollTop = element.scrollHeight - element.clientHeight;
      directionRef.current = -1;
      isPausedAtEdgeRef.current = true;
      if (pauseTimeoutIdRef.current) clearTimeout(pauseTimeoutIdRef.current);
      pauseTimeoutIdRef.current = setTimeout(() => {
        isPausedAtEdgeRef.current = false;
        lastTimestampRef.current = 0;
        if (!isInteractingRef.current && isEnabled) {
          animationFrameIdRef.current = requestAnimationFrame(animateScroll);
        }
      }, pauseDelayMs);
    } else if (directionRef.current === -1 && atTop) {
      newScrollTop = 0;
      directionRef.current = 1;
      isPausedAtEdgeRef.current = true;
      if (pauseTimeoutIdRef.current) clearTimeout(pauseTimeoutIdRef.current);
      pauseTimeoutIdRef.current = setTimeout(() => {
        isPausedAtEdgeRef.current = false;
        lastTimestampRef.current = 0;
        if (!isInteractingRef.current && isEnabled) {
          animationFrameIdRef.current = requestAnimationFrame(animateScroll);
        }
      }, pauseDelayMs);
    }
    element.scrollTop = newScrollTop;
    if (!isPausedAtEdgeRef.current && isEnabled) {
      animationFrameIdRef.current = requestAnimationFrame(animateScroll);
    } else {
      animationFrameIdRef.current = null;
    }
  }, [scrollContainerRef, pixelsPerSecond, pauseDelayMs, isEnabled]);

  const startAnimation = useCallback(() => {
    if (!scrollContainerRef.current || isInteractingRef.current || animationFrameIdRef.current || !isEnabled) {
      return;
    }
    const el = scrollContainerRef.current;
    if (el.scrollHeight <= el.clientHeight +1) {
      setIsActuallyScrolling(false);
      return;
    }
    setIsActuallyScrolling(true);
    isPausedAtEdgeRef.current = false;
    if (pauseTimeoutIdRef.current) clearTimeout(pauseTimeoutIdRef.current);
    lastTimestampRef.current = 0;
    animationFrameIdRef.current = requestAnimationFrame(animateScroll);
  }, [scrollContainerRef, animateScroll, isEnabled]);

  const stopAnimation = useCallback(() => {
    if (animationFrameIdRef.current) {
      cancelAnimationFrame(animationFrameIdRef.current);
      animationFrameIdRef.current = null;
    }
    isPausedAtEdgeRef.current = false;
    if (pauseTimeoutIdRef.current) clearTimeout(pauseTimeoutIdRef.current);
    lastTimestampRef.current = 0;
    setIsActuallyScrolling(false);
  }, []);

  useEffect(() => {
    const element = scrollContainerRef.current;
    if (!element || !isEnabled) {
      stopAnimation();
      return;
    }
    // ... (reste des event listeners inchang√©s par rapport √† ma Prop. 7) ...
    const handlePointerEnter = () => {
      isInteractingRef.current = true;
      stopAnimation();
    };
    const handlePointerLeave = () => {
      isInteractingRef.current = false;
      startAnimation();
    };
    let touchIdentifier: number | null = null;
    const handleTouchStart = (e: TouchEvent) => {
      if (touchIdentifier === null) {
        touchIdentifier = e.changedTouches[0].identifier;
        isInteractingRef.current = true;
        stopAnimation();
      }
    };
    const handleTouchEnd = (e: TouchEvent) => {
      let touchEnded = false;
      for (let i = 0; i < e.changedTouches.length; i++) {
        if (e.changedTouches[i].identifier === touchIdentifier) {
          touchEnded = true;
          break;
        }
      }
      if (touchEnded) {
        touchIdentifier = null;
        isInteractingRef.current = false;
        setTimeout(startAnimation, 100); 
      }
    };
    element.addEventListener('pointerenter', handlePointerEnter);
    element.addEventListener('pointerleave', handlePointerLeave);
    element.addEventListener('touchstart', handleTouchStart, { passive: true });
    element.addEventListener('touchend', handleTouchEnd);
    element.addEventListener('touchcancel', handleTouchEnd);
    const startTimeoutId = setTimeout(startAnimation, 500);
    return () => {
      clearTimeout(startTimeoutId);
      stopAnimation();
      element.removeEventListener('pointerenter', handlePointerEnter);
      element.removeEventListener('pointerleave', handlePointerLeave);
      element.removeEventListener('touchstart', handleTouchStart);
      element.removeEventListener('touchend', handleTouchEnd);
      element.removeEventListener('touchcancel', handleTouchEnd);
    };
  }, [scrollContainerRef, startAnimation, stopAnimation, isEnabled]);

  return { isScrolling: isActuallyScrolling };
}
--------------------------------------------------
]]

['dividends\useChartJs.ts': [
--------------------------------------------------
// # hook client
'use client';

import { useEffect, useRef, useState, useCallback } from 'react';
import { Chart, ChartConfiguration, ChartOptions, ChartTypeRegistry, TooltipItem, Point, BubbleDataPoint } from 'chart.js';
import { getChartContext, commonChartOptions, getCssVariableColor } from '@/lib/dividends/chartUtils';
import {
  paymentRatioDoughnutData,
  epsDividendChartData,
  averagesChartData,
  seasonalityChartData,
  jjChartColors
} from '@/lib/dividends/data';

// Enregistrer les contr√¥leurs, √©chelles, etc., n√©cessaires globalement pour Chart.js
// Chart.register(...); // Si des √©l√©ments sp√©cifiques doivent √™tre enregistr√©s

interface UseChartJsParams {
  chartId: string;
  chartType: keyof ChartTypeRegistry | 'doughnut-payment' | 'eps-dividend' | 'averages' | 'seasonality';
  initialDataType?: 'annual' | 'trim'; // Pour EPS/Dividend
  // Autres options sp√©cifiques au graphique si n√©cessaire
}

export function useChartJs({ chartId, chartType, initialDataType }: UseChartJsParams) {
  const chartInstanceRef = useRef<Chart | null>(null);
  const [currentDataType, setCurrentDataType] = useState<'annual' | 'trim' | undefined>(initialDataType);

  const destroyChart = useCallback(() => {
    if (chartInstanceRef.current) {
      chartInstanceRef.current.destroy();
      chartInstanceRef.current = null;
    }
  }, []);

  const initializeChart = useCallback(() => {
    if (typeof window === 'undefined') {
      console.warn("Chart.js n'est pas encore charg√©.");
      return;
    }
    if (chartInstanceRef.current) {
      destroyChart();
    }

    const ctx = getChartContext(chartId);
    if (!ctx) return;

    let config: ChartConfiguration<
      keyof ChartTypeRegistry,
      (number | Point | [number, number] | BubbleDataPoint | null)[],
      unknown
    >;

    switch (chartType) {
      case 'doughnut-payment':
        const paymentRatio = paymentRatioDoughnutData.paymentRatio;
        const notShared = 100 - paymentRatio;
        config = {
          type: 'doughnut',
          data: {
              datasets: [{
                data: [paymentRatio, notShared],
                backgroundColor: [
                  getCssVariableColor('--dividends-doughnut-color-payment', jjChartColors.doughnutPayment),
                  getCssVariableColor('--dividends-doughnut-color-not-shared', jjChartColors.doughnutNotShared)
                ],
                borderColor: [ // Pour √©viter les lignes entre les segments si cutout est grand
                  getCssVariableColor('--dividends-bg-primary', '#102a43'),
                  getCssVariableColor('--dividends-bg-primary', '#102a43')
                ],
                borderWidth: 2 // Ou 0 si pas de bordure souhait√©e
              }]
            },
            options: {
              ...commonChartOptions,
              responsive: true,
              maintainAspectRatio: true, // Important pour doughnut
              aspectRatio: 1, // Pour qu'il soit carr√©
              cutout: '60%', // Place cutout for doughnut charts
              plugins: {
                ...(commonChartOptions.plugins || {}),
                tooltip: {
                  ...(commonChartOptions.plugins?.tooltip || {}),
                  enabled: true, // Activer les tooltips pour le doughnut
                  callbacks: {
                    label: function(context: TooltipItem<'doughnut'>) {
                        let label = context.dataset.label || '';
                        if (context.dataIndex === 0) label = 'Payment Ratio (TTM)';
                        else label = 'Earnings not shared';
                        
                        if (label) label += ': ';
                        if (context.parsed !== null) {
                            label += context.parsed.toLocaleString('fr-FR', {minimumFractionDigits: 2, maximumFractionDigits: 2}) + '%';
                        }
                        return label;
                    }
                  }
                }
              }
            } as unknown as ChartOptions<'doughnut'>
        };
        break;

      case 'eps-dividend':
        const dataTypeForEps = currentDataType || 'annual';
        const epsData = epsDividendChartData[dataTypeForEps];
        config = {
          type: 'bar', // Ajout du type requis pour Chart.js, m√™me pour les graphiques combin√©s
          // Type est d√©fini au niveau des datasets pour les graphiques combin√©s
          data: {
            labels: epsData.labels,
            datasets: epsData.datasets.map(ds => ({
              ...ds,
              // S'assurer que les couleurs sont bien appliqu√©es si elles viennent de jjChartColors
              backgroundColor: ds.type === 'bar' ? getCssVariableColor('--dividends-text-light', jjChartColors.light) + 'CC' : getCssVariableColor('--dividends-accent-yellow', jjChartColors.yellow) + '40',
              borderColor: ds.type === 'bar' ? getCssVariableColor('--dividends-text-light', jjChartColors.light) : getCssVariableColor('--dividends-accent-yellow', jjChartColors.yellow),
              pointBackgroundColor: ds.type === 'line' ? getCssVariableColor('--dividends-accent-yellow', jjChartColors.yellow) : undefined,
              pointBorderColor: ds.type === 'line' ? getCssVariableColor('--dividends-text-primary', jjChartColors.primary) : undefined,
            }))
          },
          options: {
            ...commonChartOptions,
            scales: {
              ...commonChartOptions.scales,
              x: {
                ...commonChartOptions.scales?.x,
                grid: { display: false } // Pas de grille verticale pour ce graphique
              },
              yBar: { // Axe Y pour les barres (Dividend Per Share)
                type: 'linear',
                position: 'left',
                beginAtZero: true,
                ticks: { ...commonChartOptions.scales?.y?.ticks, color: getCssVariableColor('--dividends-text-secondary', jjChartColors.secondary) },
                grid: { ...commonChartOptions.scales?.y?.grid, color: getCssVariableColor('--dividends-grid-color', jjChartColors.grid), drawOnChartArea: true },
                title: { display: false }
              },
              yLine: { // Axe Y pour la ligne (Dividend Return)
                type: 'linear',
                position: 'right',
                beginAtZero: false, // Le rendement peut √™tre n√©gatif
                ticks: {
                  ...commonChartOptions.scales?.y?.ticks,
                  color: getCssVariableColor('--dividends-text-secondary', jjChartColors.secondary),
                  padding: 5,
                  callback: function (value: string | number) {
                    if (typeof value !== 'number') return value;
                    return value.toLocaleString('fr-FR', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) + '%';
                  }
                },
                grid: { drawOnChartArea: false }, // Pas de grille pour cet axe
                title: { display: false }
              }
            }
          }
        };
        break;
      
      case 'averages':
        config = {
            type: 'line',
            data: {
                labels: averagesChartData.labels,
                datasets: averagesChartData.datasets.map(ds => ({
                    ...ds,
                    borderColor: ds.label === 'Avg 1' ? getCssVariableColor('--dividends-accent-cyan', jjChartColors.cyan2) : getCssVariableColor('--dividends-accent-yellow', jjChartColors.yellow),
                }))
            },
            options: {
                ...commonChartOptions,
                scales: {
                    ...commonChartOptions.scales,
                    x: { ...commonChartOptions.scales?.x, display: true }, // Afficher l'axe X
                    y: { ...commonChartOptions.scales?.y, position: 'left' }
                }
            }
        };
        break;

      case 'seasonality':
        config = {
            type: 'line',
            data: {
                labels: seasonalityChartData.labels,
                datasets: seasonalityChartData.datasets.map(ds => ({
                    ...ds,
                    borderColor: ds.label === 'S 1' ? getCssVariableColor('--dividends-accent-pink', jjChartColors.pink2) : getCssVariableColor('--dividends-accent-yellow-dark', jjChartColors.yellow2),
                }))
            },
            options: {
                ...commonChartOptions,
                 scales: {
                    ...commonChartOptions.scales,
                    x: { ...commonChartOptions.scales?.x },
                    y: { ...commonChartOptions.scales?.y, position: 'left' }
                }
            }
        };
        break;

      default:
        // Provide a fallback config to avoid using 'config' before assignment
        config = {
          type: 'bar',
          data: {
            labels: [],
            datasets: []
          },
          options: {
            ...commonChartOptions
          }
        };
        break;
    }

    chartInstanceRef.current = new Chart(ctx, config);
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [chartId, chartType, destroyChart, currentDataType]); // currentDataType pour EPS

  useEffect(() => {
    initializeChart();
    return () => {
      destroyChart();
    };
  }, [initializeChart, destroyChart]);

  const updateDataType = useCallback((newType: 'annual' | 'trim') => {
    if (chartType === 'eps-dividend') {
      setCurrentDataType(newType);
      // L'initialisation sera refaite par le useEffect ci-dessus gr√¢ce √† la d√©pendance currentDataType
    }
  }, [chartType]);
  
  // Pour forcer une r√©-initialisation si les couleurs CSS changent (ex: changement de th√®me)
  const refreshChartColors = useCallback(() => {
      // TODO: Ajouter une logique pour d√©tecter le changement de th√®me si n√©cessaire
      // Pour l'instant, on peut juste r√©initialiser.
      if (chartInstanceRef.current) {
          initializeChart();
      }
  }, [initializeChart]);


  return { chart: chartInstanceRef.current, updateDataType, refreshChartColors };
}
--------------------------------------------------
]]

['dividends\useRevealOnScroll.ts': [
--------------------------------------------------
// # hook client
'use client';

import { useEffect, useRef } from 'react';

interface UseRevealOnScrollOptions {
  root?: Element | Document | null;
  rootMargin?: string;
  threshold?: number | number[];
  targetSelector: string; // S√©lecteur CSS pour les √©l√©ments √† r√©v√©ler
  visibleClass: string; // Classe √† ajouter lorsque l'√©l√©ment est visible (ex: 'is-visible')
  isEnabled?: boolean;
}

export function useRevealOnScroll({
  root = null,
  rootMargin = '0px',
  threshold = 0.1,
  targetSelector = '.reveal-on-scroll', // Correspond au CSS global
  visibleClass = 'is-visible', // Correspond au CSS global
  isEnabled = true,
}: UseRevealOnScrollOptions) {
  const observerRef = useRef<IntersectionObserver | null>(null);

  useEffect(() => {
    if (!isEnabled || typeof window === 'undefined' || !window.IntersectionObserver) {
      // Si d√©sactiv√© ou IntersectionObserver n'est pas support√©, s'assurer que les √©l√©ments sont visibles
      if (!isEnabled || !window.IntersectionObserver) {
        document.querySelectorAll(targetSelector).forEach(el => el.classList.add(visibleClass));
      }
      return;
    }

    if (observerRef.current) {
      observerRef.current.disconnect();
    }

    const callback: IntersectionObserverCallback = (entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.add(visibleClass);
          // Optionnel: arr√™ter d'observer une fois r√©v√©l√© pour la performance
          // obs.unobserve(entry.target);
        }
        // Optionnel: retirer la classe si l'√©l√©ment redevient non visible (pour des animations r√©p√©t√©es)
        // else {
        //   entry.target.classList.remove(visibleClass);
        // }
      });
    };

    observerRef.current = new IntersectionObserver(callback, { root, rootMargin, threshold });
    const elementsToObserve = document.querySelectorAll(targetSelector);
    elementsToObserve.forEach(el => observerRef.current?.observe(el));

    return () => {
      observerRef.current?.disconnect();
    };
  }, [root, rootMargin, threshold, targetSelector, visibleClass, isEnabled]);

  // Ce hook n'a pas besoin de retourner quoi que ce soit, il agit sur le DOM.
}
--------------------------------------------------
]]

['dividends\useScrollManagement.ts': [
--------------------------------------------------
// # hook client
'use client';

import { useState, useEffect, useCallback, RefObject } from 'react';
import {
  getHorizontalScrollState,
  getVerticalScrollState,
  smoothHorizontalScroll,
  smoothVerticalScroll,
  updateFadeClasses,
  ScrollState
} from '@/lib/dividends/scrollUtils';

interface UseScrollManagementParams {
  scrollableRef: RefObject<HTMLElement>; // L'√©l√©ment qui a la barre de scroll
  containerRef?: RefObject<HTMLElement>; // Le conteneur parent qui affiche les fades/indicateurs
  direction: 'horizontal' | 'vertical';
  // Options pour les classes de fade (utilis√©es si :has n'est pas support√© ou pour JS explicite)
  fadeClasses?: {
    hasLeftClass?: string;
    hasRightClass?: string;
    showTopClass?: string;
    showBottomClass?: string;
  }
}

export function useScrollManagement({
  scrollableRef,
  containerRef, // Peut √™tre le m√™me que scrollableRef si les fades sont sur l'√©l√©ment scrollable lui-m√™me
  direction,
  fadeClasses,
}: UseScrollManagementParams) {
  const [scrollState, setScrollState] = useState<ScrollState>({});

  const updateIndicators = useCallback(() => {
    const element = scrollableRef.current;
    if (element) {
      let newScrollState: ScrollState = {};
      if (direction === 'horizontal') {
        newScrollState = getHorizontalScrollState(element);
      } else {
        newScrollState = getVerticalScrollState(element);
      }
      setScrollState(prevState => ({...prevState, ...newScrollState}));

      if (fadeClasses && (containerRef?.current || scrollableRef.current)) {
        updateFadeClasses(containerRef?.current || element, newScrollState, fadeClasses);
      }
    }
  }, [scrollableRef, containerRef, direction, fadeClasses]);

  useEffect(() => {
    const element = scrollableRef.current;
    if (element) {
      // D√©lai pour s'assurer que le contenu est rendu et les dimensions sont correctes
      const timer = setTimeout(updateIndicators, 50); // Un d√©lai court
      
      element.addEventListener('scroll', updateIndicators, { passive: true });
      
      const resizeObserver = new ResizeObserver(updateIndicators);
      resizeObserver.observe(element);
      if (element.firstElementChild) { // Observer aussi le contenu pour les changements de taille
        resizeObserver.observe(element.firstElementChild);
      }
      
      // Observer les changements de contenu qui pourraient affecter la scrollabilit√©
      const mutationObserver = new MutationObserver(updateIndicators);
      mutationObserver.observe(element, { childList: true, subtree: true, characterData: true });


      return () => {
        clearTimeout(timer);
        element.removeEventListener('scroll', updateIndicators);
        resizeObserver.disconnect();
        mutationObserver.disconnect();
      };
    }
  }, [updateIndicators, scrollableRef]);

  const handleScrollAction = useCallback((dir: 'left' | 'right' | 'up' | 'down') => {
    if (direction === 'horizontal' && (dir === 'left' || dir === 'right')) {
      smoothHorizontalScroll(scrollableRef.current, dir);
    } else if (direction === 'vertical' && (dir === 'up' || dir === 'down')) {
      smoothVerticalScroll(scrollableRef.current, dir);
    }
  }, [direction, scrollableRef]);

  return { ...scrollState, handleScrollAction, updateIndicators };
}
--------------------------------------------------
]]

['dividends\useTradingViewChart.ts': [
--------------------------------------------------
// # hook client
'use client';
import { useEffect, useRef, useCallback } from 'react';
import { IChartApi, ISeriesApi, createChart, AreaSeries, PriceLineSource, DeepPartial, ChartOptions as LightweightChartOptions, HistogramSeriesOptions, AreaSeriesOptions } from 'lightweight-charts'; // Ajout HistogramSeriesOptions
import { getTradingViewChartBaseOptions, getAreaSeriesOptions, getVolumeSeriesOptions } from '@/lib/dividends/tradingViewUtils';
import { areaDataTV, volumeDataTV, jjChartColors } from '@/lib/dividends/data'; // Ajout jjChartColors

interface UseTradingViewChartParams {
  containerId: string;
  initialChartType?: 'volume' | 'seriesMarkers' | 'movingAverage';
}

export function useTradingViewChart({ containerId, initialChartType = 'volume' }: UseTradingViewChartParams) {
  const chartRef = useRef<IChartApi | null>(null);
  const resizeObserverRef = useRef<ResizeObserver | null>(null);
  const areaSeriesRef = useRef<ISeriesApi<"Area"> | null>(null);
  const volumeSeriesRef = useRef<ISeriesApi<"Histogram"> | null>(null);

  const destroyChart = useCallback(() => {
    if (resizeObserverRef.current) {
      resizeObserverRef.current.disconnect();
      resizeObserverRef.current = null;
    }
    if (chartRef.current) {
      chartRef.current.remove();
      chartRef.current = null;
    }
    areaSeriesRef.current = null;
    volumeSeriesRef.current = null;
  }, []);

  const initializeChart = useCallback(() => {
    if (typeof window === 'undefined' || typeof createChart === 'undefined') {
      console.warn("LightweightCharts n'est pas encore charg√©.");
      return;
    }
    const chartContainer = document.getElementById(containerId);
    if (!chartContainer) {
      console.error(`Conteneur TradingView #${containerId} introuvable.`);
      return;
    }
    destroyChart(); 

    try {
      const chartOptions = getTradingViewChartBaseOptions();
      const chart = createChart(chartContainer, chartOptions as LightweightChartOptions); // Cast pour compatibilit√©
      chartRef.current = chart;

      const areaSeriesOptions = getAreaSeriesOptions();
      const areaSeries = chart.addSeries(AreaSeries, areaSeriesOptions as DeepPartial<AreaSeriesOptions>); // Cast
      areaSeries.setData(areaDataTV);
      areaSeries.priceScale().applyOptions({ scaleMargins: { top: 0.4, bottom: 0.4 } });
      areaSeriesRef.current = areaSeries;

      const baseVolumeSeriesOptions = getVolumeSeriesOptions();
      const { title, priceLineVisible = true, priceLineSource, baseLineVisible = false, ...restBaseVolumeSeriesOptions } = baseVolumeSeriesOptions;
      const cleanedOptions = restBaseVolumeSeriesOptions as { baseLineColor?: string };
      
      const volumeSeriesOptionsTyped: DeepPartial<HistogramSeriesOptions> = { // Utilisation de DeepPartial<HistogramSeriesOptions>
        baseLineColor: baseLineVisible ? (typeof cleanedOptions.baseLineColor === 'string' ? cleanedOptions.baseLineColor : jjChartColors.tvText) : 'transparent',
        base: 0,
        lastValueVisible: true,
        visible: true,
        ...restBaseVolumeSeriesOptions,
        baseLineVisible,
        priceFormat: { type: 'volume', precision: 0, minMove: 1 },
        priceLineVisible,
        priceLineWidth: 1,
        priceLineColor: jjChartColors.tvVolumeUp, 
        title: title || '',
        priceLineSource: priceLineSource || PriceLineSource.LastVisible,
        priceLineStyle: 0,
      };
      
      const chartTyped = chart as IChartApi & { 
        addCustomSeries?: (type: string, options: DeepPartial<HistogramSeriesOptions>) => ISeriesApi<"Histogram">; 
        addHistogramSeries?: (options: DeepPartial<HistogramSeriesOptions>) => ISeriesApi<"Histogram">; 
      };

      const volumeSeries = chartTyped.addHistogramSeries ? chartTyped.addHistogramSeries(volumeSeriesOptionsTyped) : null;

      if (volumeSeries) {
        volumeSeries.setData(volumeDataTV);
        volumeSeries.priceScale().applyOptions({ scaleMargins: { top: 0.65, bottom: 0 } });
      }
      volumeSeriesRef.current = volumeSeries;

      if (volumeSeriesRef.current) {
        volumeSeriesRef.current.applyOptions({ visible: initialChartType === 'volume' });
      }
      chart.timeScale().fitContent();

      resizeObserverRef.current = new ResizeObserver(entries => {
        requestAnimationFrame(() => {
          if (!entries || !entries.length || !entries[0].contentRect) return;
          const { width, height } = entries[0].contentRect;
          if (width > 0 && height > 0 && chartRef.current) {
            chartRef.current.resize(width, height);
          }
        });
      });
      resizeObserverRef.current.observe(chartContainer);
    } catch (e) {
      console.error(`Erreur critique lors de l'initialisation de TradingView #${containerId}:`, e);
      if (chartContainer) chartContainer.innerHTML = `<div class="text-danger p-2 small">Erreur chargement graphique TV.</div>`;
      destroyChart();
    }
  }, [containerId, destroyChart, initialChartType]);

  useEffect(() => {
    const timeoutId = setTimeout(() => {
      initializeChart();
    }, 100);
    return () => {
      clearTimeout(timeoutId);
      destroyChart();
    };
  }, [initializeChart, destroyChart]);

  const setSeriesVisibility = useCallback((type: 'volume' | 'seriesMarkers' | 'movingAverage', visible: boolean) => {
    if (type === 'volume' && volumeSeriesRef.current) {
      volumeSeriesRef.current.applyOptions({ visible });
    }
  }, []);

  return { chart: chartRef.current, areaSeries: areaSeriesRef.current, volumeSeries: volumeSeriesRef.current, setSeriesVisibility };
}
--------------------------------------------------
]]

================================================================================
FIN DE L'EXTRACTION
================================================================================
‚úÖ 5 fichiers extraits avec succ√®s
üìÖ Extraction termin√©e le 2025-05-26 17:13:47