================================================================================
CODEBASE EXTRACTION REPORT
================================================================================
Projet: dividends
Chemin: D:\DONNEES\Bureau\WORSPACE-STAGIAIRE\Next.js 2025\algoway-front\algoway-front\src\lib\dividends
Date d'extraction: 2025-05-26 17:15:25
Syst√®me: windows 64bit

STATISTIQUES DU PROJET:
------------------------------
üìÅ Total dossiers: 0
üìÑ Total fichiers: 4
üíª Fichiers de code: 4

STRUCTURE DU PROJET:
------------------------------
dividends/
‚îú‚îÄ‚îÄ chartUtils.ts
‚îú‚îÄ‚îÄ data.ts
‚îú‚îÄ‚îÄ scrollUtils.ts
‚îî‚îÄ‚îÄ tradingViewUtils.ts

================================================================================
CONTENU DES FICHIERS DE CODE
================================================================================

['chartUtils.ts': [
--------------------------------------------------
import { ChartOptions } from 'chart.js';
import { jjChartColors } from './data'; // Vos couleurs d√©finies

/**
 * R√©cup√®re le contexte 2D d'un canvas par son ID.
 * @param canvasId - L'ID de l'√©l√©ment canvas.
 * @returns Le contexte 2D ou null si non trouv√©.
 */
export function getChartContext(canvasId: string): CanvasRenderingContext2D | null {
  if (typeof window === 'undefined') return null; // V√©rification c√¥t√© client
  const canvas = document.getElementById(canvasId) as HTMLCanvasElement | null;
  if (!canvas) {
    console.error(`üí• Canvas ${canvasId} introuvable`);
    return null;
  }
  return canvas.getContext('2d');
}

/**
 * Options communes pour les graphiques Chart.js.
 */
export const commonChartOptions: ChartOptions<'line' | 'bar'> = { // Types de graphiques support√©s
  responsive: true,
  maintainAspectRatio: false,
  plugins: {
    legend: {
      display: false, // L√©gendes g√©r√©es en HTML custom via ChartPlaceholder
    },
    tooltip: {
      backgroundColor: 'rgba(0, 0, 0, 0.8)',
      titleColor: jjChartColors.primary,
      bodyColor: jjChartColors.light,
      borderColor: jjChartColors.secondary,
      borderWidth: 1,
      padding: 8,
      boxPadding: 4,
      mode: 'index',
      intersect: false,
      callbacks: {
        // Personnaliser le contenu du tooltip si n√©cessaire
        // label: function(context: TooltipItem<any>) {
        //   let label = context.dataset.label || '';
        //   if (label) {
        //     label += ': ';
        //   }
        //   if (context.parsed.y !== null) {
        //     label += new Intl.NumberFormat('fr-FR', { style: 'decimal', minimumFractionDigits: 2 }).format(context.parsed.y);
        //   }
        //   return label;
        // }
      }
    },
  },
  scales: {
    x: {
      ticks: {
        color: jjChartColors.secondary,
        font: {
          size: 10,
        },
      },
      grid: {
        color: jjChartColors.grid,
      },
    },
    y: { // Axe Y par d√©faut (gauche)
      ticks: {
        color: jjChartColors.secondary,
        font: {
          size: 10,
        },
        callback: function (value: string | number) {
          if (typeof value !== 'number') return value;
          if (Math.abs(value) >= 1e9) return (value / 1e9).toFixed(1).replace('.', ',') + 'B';
          if (Math.abs(value) >= 1e6) return (value / 1e6).toFixed(1).replace('.', ',') + 'M';
          if (Math.abs(value) < 100 && Math.abs(value) !== 0) { // Pour EPS/Dividend
            return value.toLocaleString('fr-FR', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
          }
          return value.toLocaleString('fr-FR');
        },
      },
      grid: {
        color: jjChartColors.grid,
      },
      beginAtZero: false, // Peut √™tre surcharg√© par graphique sp√©cifique
    },
  },
  interaction: {
    mode: 'index',
    intersect: false,
  },
};

/**
 * Met √† jour les donn√©es d'un graphique Chart.js existant.
 * @param chartInstance - L'instance du graphique Chart.js.
 * @param newData - Les nouvelles donn√©es (labels et datasets).
 */
import { Chart, ChartData, ChartType } from 'chart.js';

export function updateChartInstanceData<TType extends ChartType>(
  chartInstance: Chart<TType>,
  newData: ChartData<TType>
) {
  if (!chartInstance || !newData?.labels || !newData?.datasets) {
    console.error("üö´ Mise √† jour graphique impossible: instance ou donn√©es invalides.", {
      chartInstancePresent: !!chartInstance,
      newDataPresent: !!newData,
    });
    return;
  }
  chartInstance.data.labels = [...newData.labels];
  chartInstance.data.datasets = newData.datasets.map((newDs: import('chart.js').ChartDataset<TType, unknown>) => ({
    ...newDs,
    data: Array.isArray(newDs.data) ? [...newDs.data] : [],
  }));
  chartInstance.update();
  // console.log(`üîÑ Donn√©es mises √† jour pour le graphique:`, chartInstance.canvas.id);
}

/**
 * R√©cup√®re une couleur depuis les variables CSS globales.
 * Utile si les couleurs des graphiques doivent correspondre exactement au th√®me CSS.
 * @param varName - Le nom de la variable CSS (ex: '--dividends-accent-yellow').
 * @param fallbackColor - Une couleur de secours si la variable n'est pas trouv√©e.
 * @returns La couleur de la variable CSS ou la couleur de secours.
 */
export function getCssVariableColor(varName: string, fallbackColor: string): string {
  if (typeof window === 'undefined') return fallbackColor;
  const color = getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
  return color || fallbackColor;
}
--------------------------------------------------
]]

['data.ts': [
--------------------------------------------------
// üé® Palette de couleurs Jack-Josias (utilis√©e par les graphiques)
// Ces couleurs sont aussi d√©finies en CSS via des variables, mais utiles ici pour le JS des graphiques.
export const jjChartColors = {
  primary: '#ffffff',
  secondary: '#A0AEC0', // Utilis√© pour les ticks des axes
  light: '#d9d9d9',     // Utilis√© pour les barres Dividend Per Share
  cyan: '#03786e',
  cyan2: '#00C4C9',    // Utilis√© pour AveragesChart
  yellow: '#ff9e04',   // Utilis√© pour Dividend Return (ligne) et AveragesChart
  yellow2: '#FFC403',  // Utilis√© pour SeasonalityChart
  pink: '#ce4243',
  pink2: '#E80054',    // Utilis√© pour SeasonalityChart
  success: '#03786e',
  danger: '#ce4243',
  grid: 'rgba(50, 75, 85, 0.5)', // Couleur des grilles Chart.js
  reported: '#CB7F04',
  noData: '#a0aec0',
  doughnutNotShared: '#E2E8F0',
  doughnutPayment: '#03786e',
  // Couleurs sp√©cifiques TradingView (si non r√©cup√©r√©es dynamiquement du CSS)
  tvBackground: '#000000',
  tvText: '#D9D9D9',
  tvAreaTop: 'rgba(249, 12, 79, 0.5)',
  tvAreaBottom: 'rgba(255, 77, 128, 0.0)',
  tvAreaLine: '#FF4040',
  tvVolumeUp: '#26a69a',
  tvVolumeDown: '#ef5350',
};

// üíπ Donn√©es pour TradingView Lightweight Charts (mainStockChartContainer)
export const areaDataTV = [
  { time: '2018-10-19', value: 54.90 }, { time: '2018-10-22', value: 54.98 },
  { time: '2018-10-23', value: 57.21 }, { time: '2018-10-24', value: 57.42 },
  { time: '2018-10-25', value: 56.43 }, { time: '2018-10-26', value: 55.51 },
  { time: '2018-10-29', value: 56.48 }, { time: '2018-10-30', value: 58.18 },
  { time: '2018-10-31', value: 57.09 }, { time: '2018-11-01', value: 56.05 },
  { time: '2018-11-02', value: 56.63 }, { time: '2018-11-05', value: 57.21 },
  { time: '2018-11-06', value: 57.21 }, { time: '2018-11-07', value: 57.65 },
  { time: '2018-11-08', value: 58.27 }, { time: '2018-11-09', value: 58.46 },
  { time: '2018-11-12', value: 58.72 }, { time: '2018-11-13', value: 58.66 },
  { time: '2018-11-14', value: 58.94 }, { time: '2018-11-15', value: 59.08 },
  { time: '2018-11-16', value: 60.21 }, { time: '2018-11-19', value: 60.62 },
  { time: '2018-11-20', value: 59.46 }, { time: '2018-11-21', value: 59.16 },
  { time: '2018-11-23', value: 58.64 }, { time: '2018-11-26', value: 59.17 },
  { time: '2018-11-27', value: 60.65 }, { time: '2018-11-28', value: 60.06 },
  { time: '2018-11-29', value: 59.45 }, { time: '2018-11-30', value: 60.30 },
  { time: '2018-12-03', value: 58.16 }, { time: '2018-12-04', value: 58.09 },
  { time: '2018-12-06', value: 58.08 }, { time: '2018-12-07', value: 57.68 },
  { time: '2018-12-10', value: 58.27 }, { time: '2018-12-11', value: 58.85 },
  { time: '2018-12-12', value: 57.25 }, { time: '2018-12-13', value: 57.09 }
];

export const volumeDataTV = [
  { time: '2018-10-19', value: 19103293.00, color: jjChartColors.tvVolumeUp },
  { time: '2018-10-22', value: 21737523.00, color: jjChartColors.tvVolumeUp },
  { time: '2018-10-23', value: 29328713.00, color: jjChartColors.tvVolumeUp },
  { time: '2018-10-24', value: 37435638.00, color: jjChartColors.tvVolumeUp },
  { time: '2018-10-25', value: 25269995.00, color: jjChartColors.tvVolumeDown },
  { time: '2018-10-26', value: 24973311.00, color: jjChartColors.tvVolumeDown },
  // ... (reste des donn√©es volumeDataTV)
  { time: '2018-12-12', value: 18892182.00, color: jjChartColors.tvVolumeDown }
];


// üìä Donn√©es pour le graphique ET le tableau EPS/Dividend (epsDividendChart, epsDividendTable)
export const epsDividendChartData = {
  annual: {
    labels: ['2016', '2017', '2018', '2019', '2020', '2021', '2022', '2023'],
    datasets: [
      {
        type: 'bar' as const, // Important pour Chart.js v4+ avec TS
        label: 'Dividend Per Share (Year)',
        data: [5.39, 5.54, 5.45, 1.65, 5.45, 5.45, 5.45, 5.45],
        backgroundColor: jjChartColors.light + 'CC', // Opacit√©
        borderColor: jjChartColors.light,
        borderWidth: 1,
        yAxisID: 'yBar',
        order: 2
      },
      {
        type: 'line' as const,
        label: 'Dividend Return (FY) %',
        data: [2.48, 2.56, 2.68, 1.65, 2.68, 2.68, 2.68, 2.68],
        borderColor: jjChartColors.yellow,
        backgroundColor: jjChartColors.yellow + '40', // Opacit√© pour fill
        tension: 0.1,
        pointRadius: 4,
        pointBackgroundColor: jjChartColors.yellow,
        pointBorderColor: jjChartColors.primary,
        pointBorderWidth: 1,
        borderWidth: 2,
        fill: false,
        yAxisID: 'yLine',
        order: 1
      }
    ]
  },
  trim: { // Trimestriel
    labels: ['T1/23', 'T2/23', 'T3/23', 'T4/23', 'T1/24', 'T2/24', 'T3/24'],
    datasets: [
      {
        type: 'bar' as const,
        label: 'Dividend Per Share (Trim)',
        data: [1.30, 1.35, 1.32, 1.48, 1.35, 1.36, 1.39],
        backgroundColor: jjChartColors.light + 'CC',
        borderColor: jjChartColors.light,
        borderWidth: 1,
        yAxisID: 'yBar',
        order: 2
      },
      {
        type: 'line' as const,
        label: 'Dividend Return (Trim) %',
        data: [0.60, 0.65, 0.61, 0.70, 0.66, 0.67, 0.68],
        borderColor: jjChartColors.yellow,
        backgroundColor: jjChartColors.yellow + '40',
        tension: 0.1,
        pointRadius: 4,
        pointBackgroundColor: jjChartColors.yellow,
        pointBorderColor: jjChartColors.primary,
        pointBorderWidth: 1,
        borderWidth: 2,
        fill: false,
        yAxisID: 'yLine',
        order: 1
      }
    ]
  }
};

export const epsDividendTableData = {
  annual: {
    headers: ['Currency : XOF', '2016', '2017', '2018', '2019', '2020', '2021', '2022', '2023'],
    rows: [
      { label: 'Dividend Return', values: [2.48, 2.56, 2.68, 1.65, 2.68, 2.68, 2.68, 2.68], isYellow: true },
      { label: 'Dividend Per Share', values: [5.39, 5.54, 5.45, 1.65, 5.45, 5.45, 5.45, 5.45] },
      { label: 'Ratio (FY)%', values: [80.43, 68.80, 69.26, null, 69.26, 69.26, 69.26, 69.26] }
    ]
  },
  trim: {
    headers: ['Currency : XOF', 'T1/23', 'T2/23', 'T3/23', 'T4/23', 'T1/24', 'T2/24', 'T3/24'],
    rows: [
      { label: 'Dividend Return', values: [0.60, 0.65, 0.61, 0.70, 0.66, 0.67, 0.68], isYellow: true },
      { label: 'Dividend Per Share', values: [1.30, 1.35, 1.32, 1.48, 1.35, 1.36, 1.39] },
      { label: 'Ratio (Trim)%', values: [20.1, 19.5, 21.0, null, 20.5, 20.8, 20.3] }
    ]
  }
};

// üç© Donn√©es pour Doughnut Chart (paymentRatioDoughnutChart)
export const paymentRatioDoughnutData = {
  paymentRatio: 43.48, // Le pourcentage pour "Payment Ratio (TTM)"
  // Le reste (Earnings not shared) est calcul√© : 100 - paymentRatio
};

// üìä Donn√©es pour Averages Chart (averagesChart)
export const averagesChartData = {
  labels: Array.from({ length: 8 }, (_, i) => `A${i}`), // Labels g√©n√©riques
  datasets: [
    {
      label: 'Avg 1',
      data: Array.from({ length: 8 }, () => Math.random() * 20 + 50), // Donn√©es al√©atoires
      borderColor: jjChartColors.cyan2,
      tension: 0.6,
      pointRadius: 0.3,
      borderWidth: 4
    },
    {
      label: 'Avg 2',
      data: Array.from({ length: 8 }, () => Math.random() * 15 + 45), // Donn√©es al√©atoires
      borderColor: jjChartColors.yellow,
      tension: 0.6,
      pointRadius: 0.3,
      borderWidth: 4
    }
  ]
};

// üìÖ Donn√©es pour Seasonality Chart (seasonalityChart)
export const seasonalityChartData = {
  labels: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul'],
  datasets: [
    {
      label: 'S 1',
      data: [26, 27, 26.5, 28, 27.5, 27, 26.8],
      borderColor: jjChartColors.pink2,
      tension: 0.6,
      pointRadius: 0,
      borderWidth: 2
    },
    {
      label: 'S 2',
      data: [25.5, 26.5, 26, 27, 26.8, 26.5, 26.2],
      borderColor: jjChartColors.yellow2,
      tension: 0.6,
      pointRadius: 0,
      borderWidth: 2
    }
  ]
};
--------------------------------------------------
]]

['scrollUtils.ts': [
--------------------------------------------------
export const SCROLL_INDICATOR_MARGIN = 3; // Petite marge pour la d√©tection de fin de scroll

export interface ScrollState {
  canScrollLeft?: boolean;
  canScrollRight?: boolean;
  canScrollUp?: boolean;
  canScrollDown?: boolean;
}

/**
 * Met √† jour l'√©tat de scroll pour un √©l√©ment horizontal.
 * @param element L'√©l√©ment scrollable.
 * @returns Un objet avec canScrollLeft et canScrollRight.
 */
export function getHorizontalScrollState(element: HTMLElement | null): Pick<ScrollState, 'canScrollLeft' | 'canScrollRight'> {
  if (!element) return { canScrollLeft: false, canScrollRight: false };

  const currentScrollLeft = Math.round(element.scrollLeft);
  const currentScrollWidth = Math.ceil(element.scrollWidth);
  const currentClientWidth = Math.ceil(element.clientWidth);

  const canLeft = currentScrollLeft > SCROLL_INDICATOR_MARGIN;
  const canRight = currentScrollWidth - (currentScrollLeft + currentClientWidth) > SCROLL_INDICATOR_MARGIN;
  
  return { canScrollLeft: canLeft, canScrollRight: canRight };
}

/**
 * Met √† jour l'√©tat de scroll pour un √©l√©ment vertical.
 * @param element L'√©l√©ment scrollable.
 * @returns Un objet avec canScrollUp et canScrollDown.
 */
export function getVerticalScrollState(element: HTMLElement | null): Pick<ScrollState, 'canScrollUp' | 'canScrollDown'> {
  if (!element) return { canScrollUp: false, canScrollDown: false };

  const currentScrollTop = Math.round(element.scrollTop);
  const currentScrollHeight = Math.ceil(element.scrollHeight);
  const currentClientHeight = Math.ceil(element.clientHeight);

  const isScrollable = currentScrollHeight > currentClientHeight + 1; // +1 pour √©viter les faux positifs
  const canUp = isScrollable && currentScrollTop > SCROLL_INDICATOR_MARGIN;
  const canDown = isScrollable && (currentScrollHeight - (currentScrollTop + currentClientHeight)) > SCROLL_INDICATOR_MARGIN;

  return { canScrollUp: canUp, canScrollDown: canDown };
}

/**
 * Fait d√©filer un √©l√©ment horizontalement.
 * @param element L'√©l√©ment √† faire d√©filer.
 * @param direction 'left' ou 'right'.
 * @param scrollPercentage Pourcentage de la largeur visible √† faire d√©filer.
 */
export function smoothHorizontalScroll(element: HTMLElement | null, direction: 'left' | 'right', scrollPercentage: number = 0.8) {
  if (!element) return;
  const scrollAmount = element.clientWidth * scrollPercentage;
  const currentScroll = element.scrollLeft;
  element.scrollTo({
    left: direction === 'left' ? currentScroll - scrollAmount : currentScroll + scrollAmount,
    behavior: 'smooth',
  });
}

/**
 * Fait d√©filer un √©l√©ment verticalement.
 * @param element L'√©l√©ment √† faire d√©filer.
 * @param direction 'up' ou 'down'.
 * @param scrollPercentage Pourcentage de la hauteur visible √† faire d√©filer.
 */
export function smoothVerticalScroll(element: HTMLElement | null, direction: 'up' | 'down', scrollPercentage: number = 0.8) {
  if (!element) return;
  const scrollAmount = element.clientHeight * scrollPercentage;
  const currentScroll = element.scrollTop;
  element.scrollTo({
    top: direction === 'up' ? currentScroll - scrollAmount : currentScroll + scrollAmount,
    behavior: 'smooth',
  });
}

/**
 * Met √† jour les classes de fade sur un conteneur parent bas√© sur l'√©tat de scroll.
 * (Utilis√© comme fallback si :has() n'est pas support√© ou pour une logique JS explicite)
 * @param containerElement Le conteneur qui a les pseudo-√©l√©ments ::before/::after pour les fades.
 * @param scrollState L'√©tat de scroll actuel.
 * @param baseClass Le nom de la classe de base pour les fades (ex: 'hScrollContainer' ou 'vScrollContainer').
 */
export function updateFadeClasses(
    containerElement: HTMLElement | null,
    scrollState: ScrollState,
    options: {
        hasLeftClass?: string; // ex: styles.hasScrollLeft
        hasRightClass?: string;
        showTopClass?: string; // ex: styles.showTopFade
        showBottomClass?: string;
    }
) {
    if (!containerElement) return;

    if (options.hasLeftClass) containerElement.classList.toggle(options.hasLeftClass, !!scrollState.canScrollLeft);
    if (options.hasRightClass) containerElement.classList.toggle(options.hasRightClass, !!scrollState.canScrollRight);
    if (options.showTopClass) containerElement.classList.toggle(options.showTopClass, !!scrollState.canScrollUp);
    if (options.showBottomClass) containerElement.classList.toggle(options.showBottomClass, !!scrollState.canScrollDown);
}
--------------------------------------------------
]]

['tradingViewUtils.ts': [
--------------------------------------------------
import { DeepPartial, ChartOptions, TimeScaleOptions, PriceScaleOptions, SeriesOptionsCommon, AreaSeriesOptions, ColorType, LineStyle, CrosshairMode } from 'lightweight-charts';
import { jjChartColors } from './data'; // Vos donn√©es et couleurs

// D√©finir un type pour les options de Lightweight Charts si n√©cessaire
// Pour l'instant, on utilise les types de la biblioth√®que

/**
 * Options de base pour le graphique TradingView Lightweight Charts.
 * Les couleurs sont r√©cup√©r√©es dynamiquement depuis les variables CSS si possible.
 */
export function getTradingViewChartBaseOptions(): DeepPartial<ChartOptions> {
  const fontFamily = typeof window !== 'undefined' ? getComputedStyle(document.documentElement).getPropertyValue('--dividends-font-family-base').trim() || 'Roboto' : 'Roboto';
  const backgroundColor = typeof window !== 'undefined' ? getComputedStyle(document.documentElement).getPropertyValue('--dividends-tv-chart-bg').trim() || jjChartColors.tvBackground : jjChartColors.tvBackground;
  const textColor = typeof window !== 'undefined' ? getComputedStyle(document.documentElement).getPropertyValue('--dividends-tv-chart-text').trim() || jjChartColors.tvText : jjChartColors.tvText;

  return {
    layout: {
      textColor: textColor,
      background: { type: ColorType.Solid, color: backgroundColor },
      fontSize: 10,
      fontFamily: fontFamily,
    },
    grid: {
      vertLines: { visible: false },
      horzLines: { visible: false },
    },
    rightPriceScale: {
      borderVisible: false,
    } as DeepPartial<PriceScaleOptions>, // Cast pour √©viter erreur de type sur mode
    timeScale: {
      borderVisible: false,
      timeVisible: true,
      secondsVisible: false,
    } as DeepPartial<TimeScaleOptions>,
    crosshair: {
      mode: CrosshairMode.Normal,
      vertLine: { color: '#888', style: LineStyle.Dashed, labelBackgroundColor: '#333333' },
      horzLine: { color: '#888', style: LineStyle.Dashed, labelBackgroundColor: '#333333' },
    },
    handleScroll: true,
    handleScale: true,
  };
}

/**
 * Options pour la s√©rie Area (prix).
 */
export function getAreaSeriesOptions(): DeepPartial<AreaSeriesOptions> {
    const topColor = typeof window !== 'undefined' ? getComputedStyle(document.documentElement).getPropertyValue('--dividends-tv-area-top').trim() || jjChartColors.tvAreaTop : jjChartColors.tvAreaTop;
    const bottomColor = typeof window !== 'undefined' ? getComputedStyle(document.documentElement).getPropertyValue('--dividends-tv-area-bottom').trim() || jjChartColors.tvAreaBottom : jjChartColors.tvAreaBottom;
    const lineColor = typeof window !== 'undefined' ? getComputedStyle(document.documentElement).getPropertyValue('--dividends-tv-area-line').trim() || jjChartColors.tvAreaLine : jjChartColors.tvAreaLine;

  return {
    topColor: topColor,
    bottomColor: bottomColor,
    lineColor: lineColor,
    lineWidth: 2,
    priceLineVisible: false, // La ligne de prix actuelle
    lastValueVisible: true, // La derni√®re valeur sur l'√©chelle de prix
    title: "Prix", // Titre pour la l√©gende (si affich√©e)
  };
}

/**
 * Options pour la s√©rie Histogram (volume).
 * Les couleurs des barres de volume sont dans volumeDataTV.
 */
export function getVolumeSeriesOptions(): DeepPartial<SeriesOptionsCommon> {
  return {
    priceFormat: {
      type: 'volume',
    },
    priceScaleId: '', // Important pour ne pas utiliser l'√©chelle de prix principale
    lastValueVisible: true,
    priceLineVisible: false,
    title: "Volume",
    // color: dynamically set per bar in data
  };
}
--------------------------------------------------
]]

================================================================================
FIN DE L'EXTRACTION
================================================================================
‚úÖ 4 fichiers extraits avec succ√®s
üìÖ Extraction termin√©e le 2025-05-26 17:15:25